use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount, Transfer};

// The unique ID of our program. Generated by Anchor when we build.
declare_id!("AQgEzkKH5QkFYfG7kMXnnNwJEtKcaaimhCQUSW4MvDAD");

#[account]
pub struct Stream {
    pub employer: Pubkey,      // Wallet address of the employer
    pub employee: Pubkey,      // Wallet address of the employee
    pub start_time: i64,       // When the stream started (Unix timestamp)
    pub rate_per_second: u64,  // Payment rate in tokens per second
    pub deposited_amount: u64, // Total tokens deposited
    pub claimed_amount: u64,   // Total tokens already claimed
}

#[derive(Accounts)]
pub struct CreateStream<'info> {
    #[account(mut)] // Mutable because we might deduct SOL for rent
    pub employer: Signer<'info>, // The person creating & funding the stream

    /// CHECK: We only store the public key, no need to validate further
    pub employee: UncheckedAccount<'info>, // The recipient employee

    // The stream account that will store our payment terms
    #[account(
        init, // Create new account
        payer = employer, // Employer pays the rent for this account
        space = 8 + 32 + 32 + 8 + 8 + 8 + 8, // 8 (discriminator) + 32+32 (pubkeys) + 8+8+8+8 (u64 fields)
        seeds = [b"stream", employer.key().as_ref(), employee.key().as_ref()], // PDA seeds
        bump // Anchor will find the correct bump for us
    )]
    pub stream: Account<'info, Stream>, // This is the account we're creating

    // --- NEW: Vault account ---
    #[account(
        init,
        payer = employer,
        token::mint = token_mint,       // The SPL token you want to deposit (e.g., USDC)
        token::authority = stream,      // Stream PDA controls it
        seeds = [b"vault", employer.key().as_ref(), employee.key().as_ref()],
        bump
    )]
    pub vault: Account<'info, TokenAccount>,

    pub token_mint: Account<'info, anchor_spl::token::Mint>,

    pub token_program: Program<'info, Token>, // Required for token transfers

    pub system_program: Program<'info, System>, // Required for account creation
    pub rent: Sysvar<'info, Rent>,
}

#[derive(Accounts)]
pub struct depositToVault<'info>{
    #[account(mut)]
    pub employer: Signer<'info>,

    #[account(mut)]
    pub stream: Account<'info, Stream>,

    #[account(mut)]
    pub vault: Account<'info, TokenAccount>,

    #[account(mut)]
    pub employer_token_account: Account<'info, TokenAccount>,

    pub token_program: Program<'info, Token>,
}

#[program]
pub mod streaming_payroll_solana {
    use super::*;

    // Instruction #1: Create a new payment stream
    // This is called by the employer to set up recurring payments to an employee
    pub fn create_stream(
        ctx: Context<CreateStream>, // Context contains all the accounts we need
        deposited_amount: u64,      // Total amount of tokens to deposit
        rate_per_second: u64,       // How many tokens employee gets per second
    ) -> Result<()> {
        msg!("Starting create_stream instruction");

        // Get a mutable reference to the stream account we're creating
        let stream = &mut ctx.accounts.stream;

        // Initialize all the fields of our stream account
        stream.employer = ctx.accounts.employer.key(); // Who's paying
        stream.employee = ctx.accounts.employee.key(); // Who's receiving
        stream.start_time = Clock::get()?.unix_timestamp; // Start counting from NOW
        stream.rate_per_second = rate_per_second; // Set the payment rate
        stream.deposited_amount = deposited_amount; // Total funds available
        stream.claimed_amount = 0; // Nothing claimed yet

        msg!(
            " Employer: {}, Employee: {}",
            stream.employer,
            stream.employee
        );

        Ok(()) // Return success
    }

    pub fn deposit_to_vault(ctx: Context<depositToVault>,amount:u64)->Result<()>{
        // Transfer tokens from employer â†’ vault
        let cpi_accounts = Transfer {
            from: ctx.accounts.employer_token_account.to_account_info(),
            to: ctx.accounts.vault.to_account_info(),
            authority: ctx.accounts.employer.to_account_info(),
        };

        let cpi_ctx = CpiContext::new(ctx.accounts.token_program.to_account_info(), cpi_accounts);

        // Actually transfer the tokens
        token::transfer(cpi_ctx, amount)?;

        ctx.accounts.stream.deposited_amount += amount;
        msg!("Deposited {} tokens to vault", amount);
        Ok(())
    }
}
