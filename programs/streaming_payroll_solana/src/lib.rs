use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount, Transfer};

// The unique ID of our program. Generated by Anchor when we build.
declare_id!("CtiRAqpHkEkzEzsbW4in6cKNcDBdevQFGbBBsSmJsCeL");

#[account]
pub struct Stream {
    pub employer: Pubkey,      // Wallet address of the employer
    pub employee: Pubkey,      // Wallet address of the employee
    pub token_mint: Pubkey,         // NEW: Token mint address
    pub token_decimals: u8,         // NEW: Token decimals
    pub start_time: i64,       // When the stream started (Unix timestamp)
    pub rate_per_second: u64,  // Payment rate in tokens per second
    pub deposited_amount: u64, // Total tokens deposited
    pub claimed_amount: u64,   // Total tokens already claimed
    pub bump: u8,              // Bump seed for PDA signing
}

#[derive(Accounts)]
pub struct CreateStream<'info> {
    #[account(mut)] // Mutable because we might deduct SOL for rent
    pub employer: Signer<'info>, // The person creating & funding the stream

    /// CHECK: We only store the public key, no need to validate further
    pub employee: UncheckedAccount<'info>, // The recipient employee

    // The stream account that will store our payment terms
    #[account(
        init, // Create new account
        payer = employer, // Employer pays the rent for this account
        space = 8 + 32 + 32 + 32 + 1 + 8 + 8 + 8 + 8 + 1, // 8 (discriminator) + 32+32 (pubkeys) + 8+8+8+8 (u64 fields)
        seeds = [b"stream", employer.key().as_ref(), employee.key().as_ref(),token_mint.key().as_ref()], // PDA seeds
        bump // Anchor will find the correct bump for us
    )]
    pub stream: Account<'info, Stream>, // This is the account we're creating

    // --- NEW: Vault account ---
    #[account(
        init,
        payer = employer,
        token::mint = token_mint,       // The SPL token you want to deposit (e.g., USDC)
        token::authority = stream,      // Stream PDA controls it
        seeds = [b"vault", employer.key().as_ref(), employee.key().as_ref(),token_mint.key().as_ref()],
        bump
    )]
    pub vault: Account<'info, TokenAccount>,

    pub token_mint: Account<'info, anchor_spl::token::Mint>,

    pub token_program: Program<'info, Token>, // Required for token transfers

    pub system_program: Program<'info, System>, // Required for account creation
    pub rent: Sysvar<'info, Rent>,
}

#[derive(Accounts)]
pub struct depositToVault<'info> {
    #[account(mut)]
    pub employer: Signer<'info>,

    #[account(mut)]
    pub stream: Account<'info, Stream>,

    #[account(mut)]
    pub vault: Account<'info, TokenAccount>,

    #[account(mut)]
    pub employer_token_account: Account<'info, TokenAccount>,

    pub token_program: Program<'info, Token>,
}

#[derive(Accounts)]
pub struct Claim<'info> {
    /// CHECK: Employee can sign to claim
    #[account(mut)]
    pub employee: Signer<'info>,

    #[account(mut)]
    pub stream: Account<'info, Stream>,

    #[account(mut)]
    pub vault: Account<'info, TokenAccount>,

    #[account(mut)]
    pub employee_token_account: Account<'info, TokenAccount>,

    pub token_program: Program<'info, Token>,
}

#[program]
pub mod streaming_payroll_solana {
    use anchor_lang::Bump;

    use super::*;

    // Instruction #1: Create a new payment stream
    // This is called by the employer to set up recurring payments to an employee
    pub fn create_stream(
        ctx: Context<CreateStream>, // Context contains all the accounts we need
        rate_per_second: u64,       // How many tokens employee gets per second
    ) -> Result<()> {
        msg!("Starting create_stream instruction");

        // Get a mutable reference to the stream account we're creating
        let stream = &mut ctx.accounts.stream;

        stream.bump=ctx.bumps.stream;

        // Initialize all the fields of our stream account
        stream.employer = ctx.accounts.employer.key(); // Who's paying
        stream.employee = ctx.accounts.employee.key(); // Who's receiving
        stream.token_mint = ctx.accounts.token_mint.key(); // store mint
        stream.token_decimals = ctx.accounts.token_mint.decimals; // store decimals
        stream.start_time = Clock::get()?.unix_timestamp; // Start counting from NOW
        stream.rate_per_second = rate_per_second; // Set the payment rate
        stream.claimed_amount = 0; // Nothing claimed yet
        stream.deposited_amount = 0; // 

        msg!(
            " Created stream | employer: {}, employee: {}, mint: {}, decimals: {}",
            stream.employer,
            stream.employee,
            stream.token_mint,
            stream.token_decimals
        );

        
        

        Ok(()) // Return success
    }

    pub fn deposit_to_vault(ctx: Context<depositToVault>, amount: u64) -> Result<()> {

                // Validate vault mint matches stream mint
        require!(
            ctx.accounts.vault.mint == ctx.accounts.stream.token_mint,
            CustomError::InvalidVaultMint
        );

        // Validate employer_token_account mint matches stream mint
        require!(
            ctx.accounts.employer_token_account.mint == ctx.accounts.stream.token_mint,
            CustomError::InvalidEmployerTokenAccountMint
        );

        // Transfer tokens from employer → vault
        let cpi_accounts = Transfer {
            from: ctx.accounts.employer_token_account.to_account_info(),
            to: ctx.accounts.vault.to_account_info(),
            authority: ctx.accounts.employer.to_account_info(),
        };

        let cpi_ctx = CpiContext::new(ctx.accounts.token_program.to_account_info(), cpi_accounts);

        // Actually transfer the tokens
        token::transfer(cpi_ctx, amount)?;

        ctx.accounts.stream.deposited_amount += amount;
        msg!("Deposited {} tokens to vault", amount);
        Ok(())
    }

    pub fn claim(ctx: Context<Claim>) -> Result<()> {
        let stream = &mut ctx.accounts.stream;
        let clock = Clock::get()?; // Get current time from Solana clock

                // Sanity: ensure vault mint matches stream mint
        require!(
            ctx.accounts.vault.mint == stream.token_mint,
            CustomError::InvalidVaultMint
        );

        // Calculate total claimable tokens based on elapsed time
        let elapsed_time = (clock.unix_timestamp - stream.start_time).max(0) as u64;
        let total_claimable = elapsed_time.saturating_mul(stream.rate_per_second);

        // Determine amount actually claimable (cannot exceed remaining in stream)
        let amount_to_claim = total_claimable
            .saturating_sub(stream.claimed_amount)
            .min(stream.deposited_amount - stream.claimed_amount);

        // Check if there's actually anything to claim
        require!(amount_to_claim > 0, CustomError::NothingToClaim);

        // Transfer from vault → employee
    let cpi_accounts = Transfer {
        from: ctx.accounts.vault.to_account_info(),
        to: ctx.accounts.employee_token_account.to_account_info(),
        authority: stream.to_account_info(),
    };

    let seeds = &[
        b"stream",
        stream.employer.as_ref(),
        stream.employee.as_ref(),
        stream.token_mint.as_ref(),
        &[stream.bump] // bump added to Stream struct
    ];
    let signer = &[&seeds[..]];
    
    let cpi_ctx = CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), cpi_accounts, signer);
    token::transfer(cpi_ctx, amount_to_claim)?;

    // Update claimed amount
        stream.claimed_amount = stream.claimed_amount.saturating_add(amount_to_claim);

        msg!("Transferred {} tokens to employee", amount_to_claim);

        Ok(())
    }
}

#[error_code]
pub enum CustomError {
    #[msg("No tokens available to claim yet.")]
    NothingToClaim,
        #[msg("Vault mint does not match stream mint.")]
    InvalidVaultMint,
    #[msg("Employer token account mint does not match stream mint.")]
    InvalidEmployerTokenAccountMint,
    #[msg("Bump seed not found.")]
    BumpNotFound,
}
